model.add(Flatten())
model.add(Dense(number_of_classes, activation='softmax') )

# rmsprop doesn't seem to work.
# AttributeError: module 'keras.optimizers' has no attribute 'rmsprop'
#opt = keras.optimizers.rmsprop(lr =0.01, decay = 1e-6)
opt = keras.optimizers.SGD(lr = 0.01, decay = 1e-6)

es = keras.callbacks.EarlyStopping(monitor = 'val_loss', verbose = 1)

#scheduler.start()

model.compile(loss = 'categorical_crossentropy',
              optimizer = opt,
              metrics = ['accuracy'])

x_train_train = x_train_train.astype('float32')
x_train_valid = x_train_valid.astype('float32')
x_test = x_test.astype('float32')
x_train_train /= 255
x_train_valid /= 255
x_test /= 255

if not data_augmentation:
    print('Not using data augmentation.')
    model.fit(x_train_train, y_train_train,
              batch_size = batch_size,
              epochs = epochs,
              validation_data = (x_train_valid, y_train_valid),
              shuffle = True)
else:
    print('Using real-time data augmentation.')
                   # This will do preprocessing and realtime data augmentation:
    datagen = ImageDataGenerator(
        featurewise_center = False,             # set input mean to 0 over the dataset
        samplewise_center = False,              # set each sample mean to 0
        featurewise_std_normalization = False,  # divide inputs by std of the dataset
        samplewise_std_normalization = False,   # divide each input by its std
        zca_whitening = False,                  # apply ZCA whitening
        zca_epsilon = 1e-06,                    # epsilon for ZCA whitening
        rotation_range = 0,                     # randomly rotate images in the range (degrees, 0 to 180)
        width_shift_range = 0.1,                # randomly shift images horizontally (fraction of total width)
        height_shift_range = 0.1,               # randomly shift images vertically (fraction of total height)
        shear_range = 0.,                       # set range for random shear
        zoom_range = 0.,                        # set range for random zoom
        channel_shift_range = 0.,               # set range for random channel shifts
        fill_mode = 'nearest',                  # set mode for filling points outside the input boundaries
        cval = 0.,                              # value used for fill_mode = "constant"
        horizontal_flip = True,                 # randomly flip images
        vertical_flip = False,                  # randomly flip images
        rescale = None,                         # set rescaling factor (applied before any other transformation)
        preprocessing_function = None,          # set function that will be applied on each input
        data_format = None,                     # image data format, either "channels_first" or "channels_last"
        validation_split = 0.0 )                # fraction of images reserved for validation (strictly between 0 and 1)


# Compute quantities required for feature-wise normalization
# (std, mean, and principal components if ZCA whitening is applied).

datagen.fit(x_train_train)

# Fit the model on the batches generated by datagen.flow().

t0 = time.time()

m = model.fit_generator( datagen.flow( x_train_train, y_train_train, batch_size = batch_size),
                                       steps_per_epoch = 100,
                                       epochs = epochs,
                                       validation_data = (x_train_valid, y_train_valid),
                                       workers = 8,
                                       callbacks = [es],
                                       verbose = 0 )

n_epochs = len( m.history['loss'] )

t1 = time.time()
model_training_time = t1-t0
#print('model_training_time: ', model_training_time)

# Score trained model.
t2 = time.time()
scores_train_train = model.evaluate(x_train_train, y_train_train, verbose = 0)
t3 = time.time()
train_eval_time = t3-t2
#print('train_eval_time: ', train_eval_time)

t4 = time.time()
scores_test = model.evaluate(x_test, y_test, verbose = 0)
t5 = time.time()
test_eval_time = t5-t4
#print('test_eval_time: ', test_eval_time)


#scheduler.shutdown()
#cpu_time = process.cpu_times().user

#print('Training_loss: {} Test_accuracy: {} Mem: {} CPU_time: {}'.format(scores_train_train[0], scores_test[1], mmem, cpu_time) )

print('Training_loss: {} Test_accuracy: {} n_epochs: {} model_training_time: {} train_eval_time: {} test_eval_time: {}'.format( scores_train_train[0], scores_test[1], n_epochs, model_training_time, train_eval_time, test_eval_time ) )
